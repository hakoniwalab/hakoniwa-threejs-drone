<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>three.js GLB ロード＋姿勢・位置変更サンプル</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    #info {
      position: absolute;
      top: 8px;
      left: 8px;
      color: #fff;
      z-index: 10;
      font-family: sans-serif;
      font-size: 13px;
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
<div id="info">
  three.js GLB ロードサンプル<br>
  WASD: X/Z 平面移動, ↑↓: Y移動, ←→: Yaw回転
</div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
  console.log("### INDEX.HTML VERSION: HAKONIWA-TEST-2 ###");
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  const camera = new THREE.PerspectiveCamera(
    60, window.innerWidth / window.innerHeight, 0.1, 1000
  );
  camera.position.set(3, 2, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const axes = new THREE.AxesHelper(2);
  scene.add(axes);

  const planeGeo = new THREE.PlaneGeometry(20, 20);
  const planeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
  const plane = new THREE.Mesh(planeGeo, planeMat);
  plane.rotation.x = -Math.PI / 2;
  plane.position.y = -0.01;
  plane.receiveShadow = true;
  scene.add(plane);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  hemiLight.position.set(0, 10, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 3);
  dirLight.castShadow = true;
  scene.add(dirLight);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 1, 0);
  controls.update();

  const loader = new GLTFLoader();
  let model = null;
  const deg = THREE.MathUtils.degToRad;
  loader.load(
    //'models/drone_org.glb',
    'models/13113_shibuya-ku_pref_2023_citygml_2_op.glb',
    //'models/an_entire_small_town_scanned_by_a_drone.glb',
    (gltf) => {
      model = gltf.scene;
      model.position.set(0, 0, 0);
      model.rotation.set(
        deg(0), // X 回り
        deg(0),   // Y 回り
        deg(0)  // Z 回り
      );
      model.scale.set(1, 1, 1);

      model.traverse((obj) => {
        if (obj.isMesh) {
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      });

      scene.add(model);
    },
    undefined,
    (error) => {
      console.error('GLB ロード失敗:', error);
    }
  );

  const keyState = {};
  window.addEventListener('keydown', (e) => keyState[e.key] = true);
  window.addEventListener('keyup',   (e) => keyState[e.key] = false);

  function updateModelTransform(delta) {
    if (!model) return;

    const moveSpeed = 2.0;
    const rotSpeed  = Math.PI;

    if (keyState['w']) model.position.z -= moveSpeed * delta;
    if (keyState['s']) model.position.z += moveSpeed * delta;
    if (keyState['a']) model.position.x -= moveSpeed * delta;
    if (keyState['d']) model.position.x += moveSpeed * delta;
    if (keyState['ArrowUp'])   model.position.y += moveSpeed * delta;
    if (keyState['ArrowDown']) model.position.y -= moveSpeed * delta;

    if (keyState['ArrowLeft'])  model.rotation.z += rotSpeed * delta;
    if (keyState['ArrowRight']) model.rotation.z -= rotSpeed * delta;
  }

  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    updateModelTransform(delta);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>